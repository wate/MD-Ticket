#!/usr/bin/env zx
import { fileURLToPath } from "node:url";

//#region _tools/lib/pm-tool/config.js
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
/**
* 環境変数を展開する
* ${VARIABLE_NAME}形式の文字列をprocess.env.VARIABLE_NAMEに置き換える
*
* @param {string} str - 展開対象の文字列
* @returns {string} 環境変数が展開された文字列
*/
function expandEnvVars(str) {
	if (typeof str !== "string") return str;
	return str.replace(/\$\{([^}]+)\}/g, (match, varName) => {
		return process.env[varName] || match;
	});
}
/**
* オブジェクト内のすべての環境変数を再帰的に展開する
*
* @param {*} obj - 展開対象のオブジェクト
* @returns {*} 環境変数が展開されたオブジェクト
*/
function expandEnvVarsRecursive(obj) {
	if (typeof obj === "string") return expandEnvVars(obj);
	if (Array.isArray(obj)) return obj.map((item) => expandEnvVarsRecursive(item));
	if (obj !== null && typeof obj === "object") {
		const result = {};
		for (const [key, value] of Object.entries(obj)) result[key] = expandEnvVarsRecursive(value);
		return result;
	}
	return obj;
}
/**
* config.ymlを読み込み、パースする
*
* @returns {Object} パースされた設定オブジェクト
* @throws {Error} 設定ファイルが見つからない、またはパースできない場合
*/
function loadConfig() {
	const configPath = path.resolve(__dirname, "../config.yml");
	try {
		const configContent = fs.readFileSync(configPath, "utf8");
		return expandEnvVarsRecursive(YAML.parse(configContent));
	} catch (error$1) {
		if (error$1.code === "ENOENT") throw new Error(`設定ファイルが見つかりません: ${configPath}`);
		throw new Error(`設定ファイルの読み込みに失敗しました: ${error$1.message}`);
	}
}
/**
* PM Tool設定を取得する
*
* @returns {Object} PM Tool設定オブジェクト
* @throws {Error} PM Tool設定が無効な場合
*/
function getPmToolConfig() {
	const config = loadConfig();
	if (!config.integration?.pm_tool) throw new Error("config.ymlにintegration.pm_tool設定が見つかりません");
	const pmToolConfig = config.integration.pm_tool;
	if (!pmToolConfig.type) throw new Error("連携ツールが設定されていません (integration.pm_tool.type)");
	const toolName = pmToolConfig.type;
	const toolConfig = pmToolConfig[toolName];
	if (!toolConfig) throw new Error(`ツール "${toolName}" の設定が見つかりません`);
	return {
		tool: toolName,
		config: toolConfig,
		pmToolConfig
	};
}

//#endregion
//#region _tools/lib/pm-tool/common/logger.js
/**
* ログレベル定義
*/
const LOG_LEVELS = {
	DEBUG: 0,
	INFO: 1,
	WARN: 2,
	ERROR: 3
};
/**
* 現在のログレベル（環境変数PM_TOOL_LOG_LEVELで設定可能）
*/
const currentLogLevel = LOG_LEVELS[process.env.PM_TOOL_LOG_LEVEL?.toUpperCase()] ?? LOG_LEVELS.INFO;
/**
* タイムスタンプを生成する
*
* @returns {string} ISO形式のタイムスタンプ
*/
function timestamp() {
	return (/* @__PURE__ */ new Date()).toISOString();
}
/**
* ログメッセージをフォーマットする
*
* @param {string} level - ログレベル
* @param {string} message - ログメッセージ
* @param {Object} [data] - 追加データ
* @returns {string} フォーマットされたログメッセージ
*/
function formatMessage(level, message, data) {
	let formatted = `[${timestamp()}] [${level}] ${message}`;
	if (data) formatted += ` ${JSON.stringify(data)}`;
	return formatted;
}
/**
* DEBUGレベルのログを出力する
*
* @param {string} message - ログメッセージ
* @param {Object} [data] - 追加データ
*/
function debug(message, data) {
	if (currentLogLevel <= LOG_LEVELS.DEBUG) console.error(formatMessage("DEBUG", message, data));
}
/**
* INFOレベルのログを出力する
*
* @param {string} message - ログメッセージ
* @param {Object} [data] - 追加データ
*/
function info(message, data) {
	if (currentLogLevel <= LOG_LEVELS.INFO) console.error(formatMessage("INFO", message, data));
}
/**
* ERRORレベルのログを出力する
*
* @param {string} message - ログメッセージ
* @param {Error|Object} [error] - エラーオブジェクトまたは追加データ
*/
function error(message, error$1) {
	if (currentLogLevel <= LOG_LEVELS.ERROR) {
		const data = error$1 instanceof Error ? {
			message: error$1.message,
			stack: error$1.stack
		} : error$1;
		console.error(formatMessage("ERROR", message, data));
	}
}

//#endregion
//#region _tools/lib/pm-tool/common/error.js
/**
* PM Tool基底エラークラス
*/
var PmToolError = class extends Error {
	constructor(message, code, details) {
		super(message);
		this.name = "PmToolError";
		this.code = code;
		this.details = details;
	}
};

//#endregion
//#region _tools/lib/pm-tool/cli.js
/**
* 使用方法を表示する
*
* @param {Object} plugin - プラグインオブジェクト（オプション）
*/
function showUsage(plugin = null) {
	let usageText = `
使用方法:
    pm-tool issue fetch <チケット番号>  チケット情報を取得する
    pm-tool issue update <ファイルパス> チケット情報を更新する
    pm-tool help                         ヘルプを表示する

オプション:
  --help, -h                           ヘルプを表示する
  --version, -v                        バージョンを表示する
  --dry-run                            実際の更新を行わず、ペイロードのみ表示する

issue fetchコマンド用オプション:
  --stdout                             ファイル保存せず標準出力に表示する
  --json                               JSON形式で保存/出力する
  --dir <ディレクトリ>                 出力ディレクトリを指定する
  --prefix <プレフィックス>            ファイル名のプレフィックスを指定する

環境変数:
  PM_TOOL_LOG_LEVEL                    ログレベル (DEBUG, INFO, WARN, ERROR)
                                       デフォルト: INFO`;
	if (plugin && typeof plugin.getUpdateOptions === "function") {
		const options = plugin.getUpdateOptions();
		if (options && options.length > 0) {
			usageText += `\n\n${plugin.label}固有の更新オプション:`;
			for (const opt of options) {
				const padding = " ".repeat(Math.max(0, 30 - opt.name.length));
				usageText += `\n  --${opt.name}${padding}${opt.description}`;
			}
		}
	}
	usageText += `

例:
    pm-tool issue fetch 1234
    pm-tool issue fetch 1234 --stdout
    pm-tool issue fetch 1234 --json --dir ./output
    pm-tool issue update ticket-1234.md
    pm-tool issue update ticket-1234.md --dry-run`;
	if (plugin) {
		if (plugin.name === "redmine") usageText += `
      pm-tool issue fetch https://redmine.example.com/issues/1234
      pm-tool issue update ticket-1234.md --comment "実装完了"`;
		else if (plugin.name === "backlog") usageText += `
      pm-tool issue fetch PROJ-123
      pm-tool issue update task/PROJ-123.md --start-date 2025-11-01`;
	}
	console.log(usageText.trim());
}
/**
* バージョン情報を表示する
*/
function showVersion() {
	console.log("pm-tool version 0.1.0");
}
/**
* プラグインを読み込む
* バンドル済みプラグイン（lib/pm-tool/plugins/{toolName}.mjs）を動的にロードする
*
* @param {string} toolName - ツール名
* @returns {Promise<Object>} プラグインオブジェクト
*/
async function loadPlugin(toolName) {
	try {
		const plugin = await import(`./lib/pm-tool/plugins/${toolName}.mjs`);
		return plugin.default || plugin;
	} catch (error$1) {
		throw new PmToolError(`プラグイン "${toolName}" の読み込みに失敗しました`, "PLUGIN_LOAD_ERROR", {
			toolName,
			originalError: error$1.message
		});
	}
}
/**
* URLからチケット番号を抽出する
* プラグインのparseUrlメソッドを使用してURL解析を行う
*
* @param {string} input - チケット番号またはURL
* @param {string} configUrl - config.ymlで設定されたURL
* @param {Object} plugin - プラグインオブジェクト
* @returns {string} チケット番号
* @throws {PmToolError} URL不一致またはチケット番号抽出失敗
*/
function parseTicketIdFromUrl(input, configUrl, plugin) {
	const inputStr = String(input);
	if (!inputStr.startsWith("http://") && !inputStr.startsWith("https://")) return inputStr;
	try {
		const inputUrl = new URL(inputStr);
		const baseUrl = new URL(configUrl);
		if (inputUrl.protocol !== baseUrl.protocol || inputUrl.hostname !== baseUrl.hostname || inputUrl.port !== baseUrl.port) throw new PmToolError(`URLが設定と一致しません\n設定: ${configUrl}\n入力: ${inputStr}`, "URL_MISMATCH", {
			configUrl,
			inputUrl: inputStr
		});
		if (plugin && typeof plugin.parseUrl === "function") {
			const ticketId = plugin.parseUrl(inputStr);
			if (ticketId) return ticketId;
		}
		throw new PmToolError(`URLからチケット番号を抽出できませんでした: ${inputStr}`, "INVALID_URL_FORMAT", { url: inputStr });
	} catch (error$1) {
		if (error$1 instanceof PmToolError) throw error$1;
		throw new PmToolError(`不正なURL形式です: ${inputStr}`, "INVALID_URL", {
			url: inputStr,
			originalError: error$1.message
		});
	}
}
/**
* Markdown形式にフォーマットする
*
* @param {Object} data - チケットデータ
* @returns {string} Markdown形式の文字列
*/
function formatMarkdown(data) {
	const { meta, title, body } = data;
	const yamlFrontmatter = YAML.stringify(meta);
	const titleLine = title || "Untitled";
	const titleUnderline = "=".repeat(Math.max(titleLine.length, 25));
	return `---
${yamlFrontmatter.trim()}
---
${titleLine}
${titleUnderline}

${body}
`;
}
/**
* fetchコマンドを実行する
*
* @param {string} ticketIdOrUrl - チケットIDまたはURL
* @param {Object} options - オプション
*/
async function executeFetch(ticketIdOrUrl, options = {}) {
	if (!ticketIdOrUrl) throw new PmToolError("チケット番号またはURLを指定してください", "INVALID_ARGUMENT");
	const { tool, config, pmToolConfig } = getPmToolConfig();
	const plugin = await loadPlugin(tool);
	const ticketId = parseTicketIdFromUrl(ticketIdOrUrl, config.url, plugin);
	info(`チケット ${ticketId} の情報を取得します...`);
	const result = await plugin.fetch(config, ticketId, options);
	info("チケット情報の取得に成功しました");
	if (options.json) {
		if (options.dir) {
			const outputDir$1 = options.dir;
			const filename$1 = `${options.prefix || pmToolConfig.file_prefix || plugin.defaults?.file_prefix || ""}${ticketId}.json`;
			const filepath$1 = path.resolve(outputDir$1, filename$1);
			fs.mkdirSync(path.dirname(filepath$1), { recursive: true });
			fs.writeFileSync(filepath$1, JSON.stringify(result, null, 2), "utf8");
			info(`JSONファイルを保存しました: ${filepath$1}`);
			return result;
		}
		console.log(JSON.stringify(result, null, 2));
		return result;
	}
	if (options.stdout) {
		const markdown$1 = formatMarkdown(result);
		console.log(markdown$1);
		return result;
	}
	const outputDir = options.dir || pmToolConfig.output_dir || ".";
	const filename = `${options.prefix || pmToolConfig.file_prefix || plugin.defaults?.file_prefix || ""}${ticketId}.md`;
	const filepath = path.resolve(outputDir, filename);
	const markdown = formatMarkdown(result);
	fs.mkdirSync(path.dirname(filepath), { recursive: true });
	fs.writeFileSync(filepath, markdown, "utf8");
	info(`Markdownファイルを保存しました: ${filepath}`);
	return result;
}
/**
* updateコマンドを実行する
*
* @param {string} filePath - チケットファイルパス
* @param {Object} options - オプション
*/
async function executeUpdate(filePath, options = {}) {
	if (!filePath) throw new PmToolError("チケットファイルパスを指定してください", "INVALID_ARGUMENT");
	if (!fs.existsSync(filePath)) throw new PmToolError(`ファイルが見つかりません: ${filePath}`, "FILE_NOT_FOUND");
	const { tool, config } = getPmToolConfig();
	const frontmatterMatch = fs.readFileSync(filePath, "utf8").match(/^---\r?\n([\s\S]+?)\r?\n---\r?\n([\s\S]*)$/);
	if (!frontmatterMatch) throw new PmToolError("YAMLフロントマターが見つかりません", "INVALID_FORMAT");
	const frontmatter = YAML.parse(frontmatterMatch[1]);
	const bodyContent = frontmatterMatch[2].replace(/\r\n/g, "\n").replace(/\r/g, "\n").trim();
	const plugin = await loadPlugin(tool);
	const ticketId = plugin.extractTicketId(frontmatter);
	if (!ticketId) throw new PmToolError(`YAMLフロントマターからチケットIDを抽出できませんでした (${tool}プラグイン)`, "INVALID_FORMAT");
	info(`チケット ${ticketId} を更新します...`);
	const updateData = {
		...options,
		frontmatter,
		body: bodyContent,
		ticketId
	};
	const result = await plugin.update(config, ticketId, updateData);
	info("チケットの更新に成功しました");
	console.log(JSON.stringify(result, null, 2));
	return result;
}
/**
* コマンドライン引数をパースする
* zx組み込みのminimist(argv)を使用
*
* @param {string[]} args - コマンドライン引数
* @param {Object} plugin - プラグインオブジェクト（オプション、オプション定義の取得に使用）
* @returns {Object} パースされた引数
*/
function parseArgs(args, plugin = null) {
	const stringOptions = ["dir", "prefix"];
	const booleanOptions = [
		"help",
		"version",
		"dry-run",
		"stdout",
		"json"
	];
	if (plugin && typeof plugin.getUpdateOptions === "function") {
		const updateOptions = plugin.getUpdateOptions();
		for (const opt of updateOptions) if (opt.type === "string") stringOptions.push(opt.name);
		else if (opt.type === "number") stringOptions.push(opt.name);
	}
	const parsed = minimist(args, {
		string: stringOptions,
		boolean: booleanOptions,
		alias: {
			h: "help",
			v: "version"
		}
	});
	const positional = parsed._;
	if (parsed.help) return {
		command: "help",
		ticketId: null,
		options: {}
	};
	if (parsed.version) return {
		command: "version",
		ticketId: null,
		options: {}
	};
	const subcommand = positional[0] || null;
	const action = positional[1] || null;
	const target = positional[2] || null;
	const { _, help, version, h, v,...options } = parsed;
	return {
		subcommand,
		action,
		target,
		options
	};
}
/**
* メイン処理
*/
async function main() {
	try {
		let args = process.argv.slice(2);
		if (args.length > 0 && (args[0].endsWith("/pm-tool") || args[0].includes("pm-tool"))) args = args.slice(1);
		const basicParsed = parseArgs(args);
		const { subcommand, action, target } = basicParsed;
		let { options } = basicParsed;
		if (!subcommand) {
			showUsage();
			process.exit(1);
		}
		if (subcommand === "issue" && action === "update") try {
			const { tool } = getPmToolConfig();
			const plugin = await loadPlugin(tool);
			options = parseArgs(args, plugin).options;
		} catch (error$1) {
			debug("プラグインロードに失敗したため、基本パース結果を使用します", error$1);
		}
		switch (subcommand) {
			case "help":
				try {
					const { tool } = getPmToolConfig();
					showUsage(await loadPlugin(tool));
				} catch (error$1) {
					showUsage();
				}
				break;
			case "version":
				showVersion();
				break;
			case "issue":
				if (action === "fetch") {
					await executeFetch(target, options);
					break;
				}
				if (action === "update") {
					await executeUpdate(target, options);
					break;
				}
				console.error(`エラー: 不明なアクション "${action}" (issue)`);
				showUsage();
				process.exit(1);
			case "fetch":
				await executeFetch(action, options);
				break;
			case "update":
				await executeUpdate(action, options);
				break;
			default:
				console.error(`エラー: 不明なサブコマンド "${subcommand}"`);
				showUsage();
				process.exit(1);
		}
	} catch (error$1) {
		error("コマンド実行エラー", error$1);
		if (error$1 instanceof PmToolError) {
			console.error(`\nエラー: ${error$1.message}`);
			if (error$1.details) console.error("詳細:", JSON.stringify(error$1.details, null, 2));
		} else console.error(`\n予期しないエラーが発生しました: ${error$1.message}`);
		process.exit(1);
	}
}
main();

//#endregion